// Example of a stackable shader which apply's vertex animation


BEGIN_PROPERTIES
   [BetterHeader(Vertex Wave)]
   _VertexWaveFrequency("Wave Frequency", Range(0,10)) = 2
   _VertexWaveAmplitude("Wave Amplitude", Range(0,10)) = 0.3
   _VertexWaveHeightScale("Wave Height Scale", Range(1, 30)) = 9
END_PROPERTIES

BEGIN_DEFINES
	#pragma multi_compile_instancing
END_DEFINES


BEGIN_CBUFFER
	half _VertexWaveFrequency;
	half _VertexWaveAmplitude;
	half _VertexWaveHeightScale;
END_CBUFFER

BEGIN_SUBSHADERS
"Include/Skinning.cginc"  
"Include/SkinningUtils.cginc"
"Include/AnimationTypes.cginc"
END_SUBSHADERS

BEGIN_CODE

struct TextureClipInfo
{
    int IndexStart;
    int TotalLength;
    int Frames;
    int FramesPerSecond;
};

inline TextureClipInfo ToTextureClipInfo(float4 vec)
{
    TextureClipInfo ci;
    ci.IndexStart = vec.x;
    ci.TotalLength = vec.y;
    ci.Frames = vec.z;
    ci.FramesPerSecond = vec.w;
    return ci;
}

    sampler2D _Animation, _Skinning;
    float4 _Animation_TexelSize, _Skinning_TexelSize;
    float4 _CurrentAnimation;
    
    #if SHADER_TARGET < 45
    uniform float _InstanceTimeOffsets[1024];
    #elif defined(SHADER_API_D3D11) || defined(SHADER_API_METAL) || defined(SHADER_API_GLES3)
    StructuredBuffer<float> _InstanceTimeOffsets;
    #endif
    		
    float GetTime(uint id)
    {
        #if defined(UNITY_INSTANCING_ENABLED) || defined(UNITY_PROCEDURAL_INSTANCING_ENABLED)
        return _Time.y + _InstanceTimeOffsets[id];
        #else
        return _Time.y;
        #endif
    }
    
	void ModifyVertex(inout VertexData v, inout ExtraV2F d)
	{
		// only do it in this stage if we're not tessellated, otherwise lets
		// do it in the tessellated stage for better resolution
		

		#if !_TESSELLATION_ON
		   v.vertex.x += sin((_Time.y + v.vertex.y * _VertexWaveHeightScale) * _VertexWaveFrequency) * _VertexWaveAmplitude;
		#endif
		
			UNITY_SETUP_INSTANCE_ID(v);

			const float time =  _Time.y;
			const TextureClipInfo clip = ToTextureClipInfo(_CurrentAnimation);
			skin(v.vertex, v.normal, v.vertexID, _Skinning, _Skinning_TexelSize, _Animation, _Animation_TexelSize, clip.IndexStart, clip.Frames, (time * (clip.FramesPerSecond)));
	}

	void ModifyTessellatedVertex(inout VertexData v, inout ExtraV2F d)
    {
        #if _TESSELLATION_ON
    		v.vertex.x += sin((_Time.y + v.vertex.y * _VertexWaveHeightScale) * _VertexWaveFrequency) * _VertexWaveAmplitude;
    	#endif
    }

END_CODE

