#pragma kernel BakeAnimationTexture_Float4
#pragma kernel BakeBoneWeights
#pragma kernel ReadAnimation
#pragma kernel BakeAnimationMeshTexture

#include "../Include/AnimationTypes.cginc"
#include "../Include/SkinningFunctions.cginc"

StructuredBuffer<float4x4> Matrices;
RWTexture2D<float4> Texture;

/*
 *  Texture Data Layout:
 *  
 *  pixel_n: Mat_Col0
 *  pixel_n+1: Mat_Col1
 *  pixel_n+2: Mat_Col2
 *  pixel_n+3: Mat_Col3
 **/

[numthreads(32,1,1)]
void BakeAnimationTexture_Float4(uint3 id : SV_DispatchThreadID)
{
    const uint matrixIndex = id.x;
    uint matrixCount, stride;
    Matrices.GetDimensions(matrixCount, stride);
    if (matrixIndex >= matrixCount) return;
    float4x4 mat = Matrices[(uint)floor(matrixIndex)];
    uint tw, th;
    Texture.GetDimensions(tw, th);
    const uint pixelIndex = matrixIndex * 4;
    const uint end = pixelIndex + 4;

    [unroll]
    for (uint i = pixelIndex; i < end; i ++)
    {
        int x = i % tw;
        int y = floor(i / (float)tw);
        Texture[uint2(x, y)] = mat[i];
    }
}


StructuredBuffer<BoneWeight> Weights;

void Write(const uint index, const uint textureWidth, const float4 values)
{
    int x = index % textureWidth;
    int y = floor(index / (float)textureWidth);
    const uint2 coord = uint2(x, y);
    Texture[coord] = values;
}

[numthreads(32,1,1)]
void BakeBoneWeights(uint3 _id : SV_DispatchThreadID)
{
    const uint weightIndex = _id.x;
    uint weightsCount, stride;
    Weights.GetDimensions(weightsCount, stride);
    if (weightIndex >= weightsCount) return;
    uint tw, th;
    Texture.GetDimensions(tw, th);
    BoneWeight weight = Weights[weightIndex];
    int textureIndex = weightIndex * 2; // because we store a weight into two pixels
    const float4 skin01 = float4(weight.weight0, weight.boneIndex0, weight.weight1, weight.boneIndex1);
    const float4 skin23 = float4(weight.weight2, weight.boneIndex2, weight.weight3, weight.boneIndex3);
    // skin23 = 0;
    // skin01 = float4(1,0, 0, 0);
    Write(textureIndex, tw, skin01);
    textureIndex += 1;
    Write(textureIndex, tw, skin23);
}


StructuredBuffer<TextureClipInfo> Clips;
RWStructuredBuffer<Bone> Bones;

[numthreads(32,1,1)]
void ReadAnimation(uint3 _id : SV_DispatchThreadID)
{
    const uint clipIndex = _id.x;
    uint clipsCount, stride;
    Clips.GetDimensions(clipsCount, stride);
    if (clipIndex >= clipsCount) return;

    uint tw, th;
    Texture.GetDimensions(tw, th);

    // get indices from animation clips
    const TextureClipInfo clip = Clips[clipIndex];
    for (int k = 0; k < clip.TotalLength; k++)
    {
        // x4 because 4 pixel per matrix
        const uint matIndex = clip.IndexStart + k;
        const uint pixelIndex = (clip.IndexStart + k) * 4;

        // build matrix from 4 pixels
        float4x4 mat = 0;
        [unroll]
        for (uint n = 0; n < 4; n ++)
        {
            const uint ti = pixelIndex + n;
            int x = ti % tw;
            int y = floor(ti / (float)tw);
            mat[n] = Texture[uint2(x, y)];
        }

        Bone bone;
        bone.transformation = mat;
        Bones[matIndex] = bone;
    }
}


StructuredBuffer<float3> VertexPositions;
StructuredBuffer<float3> Normals;
StructuredBuffer<float4> Tangents;

[numthreads(64, 1, 1)]
void BakeAnimationMeshTexture(uint3 id : SV_DispatchThreadID)
{
    const uint vertexIndex = id.x;

    uint weightsCount, _;
    Weights.GetDimensions(weightsCount, _);
    // if (vertexIndex >= weightsCount) return;

    uint vertsCount;
    VertexPositions.GetDimensions(vertsCount, _);
    // if (vertexIndex >= vertsCount) return;

    uint clipsCount;
    Clips.GetDimensions(clipsCount, _);

    uint tw;
    Texture.GetDimensions(tw, _);

    const BoneWeight weight = Weights[vertexIndex];
    float3 vertPos = VertexPositions[vertexIndex];
    float3 normal = Normals[vertexIndex];
    float4 tangent = Tangents[vertexIndex];
    const uint requiredPixel = 2;

    int clipIndexLengths = 0;
    for(uint ci = 0; ci < clipsCount; ci++)
    {
        const TextureClipInfo clip = Clips[ci];
        
        for(int mati = 0; mati < clip.TotalLength; mati++)
        {
            int b0 = weight.boneIndex0;
            int b1 = weight.boneIndex1;
            int b2 = weight.boneIndex2;
            int b3 = weight.boneIndex3;
            
            const float w0 = weight.weight0;
            const float w1 = weight.weight1;
            const float w2 = weight.weight2;
            const float w3 = weight.weight3;
            
            b0 += clip.IndexStart;
            b1 += clip.IndexStart;
            b2 += clip.IndexStart;
            b3 += clip.IndexStart;
            
            const float4x4 m0 = Matrices[b0];
            const float4x4 m1 = Matrices[b1];
            const float4x4 m2 = Matrices[b2];
            const float4x4 m3 = Matrices[b3];

            const float4x4 mat = skinMatrix(m0, w0, m1, w1, m2, w2, m3, w3);
            const float4 pos = mul(mat, float4(vertPos, 1));
            normal = mul(mat, normal);
            tangent = mul(mat, tangent);
            const uint outIndex = (clipIndexLengths + vertexIndex + mati * vertsCount) * requiredPixel;
            Write(outIndex, tw, pos);
            Write(outIndex+1, tw, float4(normal, 0));
            Write(outIndex+2, tw, tangent);
        }
        clipIndexLengths += clip.TotalLength;
    }


   
    
}

//
// const int pixelsNeededPerVertex = 2;
// uint pixelIndex = (vertexIndex * verts + matrixIndex * verts) * pixelsNeededPerVertex;
//
// Texture[uint2(pixelIndex % tw, floor(pixelIndex / (float)tw))] = float4(pos.xyz, normal.x);
// pixelIndex += 1;
// Texture[uint2(pixelIndex % tw, floor(pixelIndex / (float)tw))] = float4(normal.z, tangent.xyz);


